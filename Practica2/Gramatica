ARRAY => array size ID
ARRAY => array exists ID
AGR => [ EXPR ]
AGR => [ ARRAY ]
AGR => [ gets stdin ]
SET => set ID VAL
SET => set VECTOR VAL
VAL => E
VAL => $ ID
VAL => AGR
VAL => VECTOR
GETS => gets stdin B
B => ;
B => epsilon
PUTS => puts P ; 
P => AGR 
P => $ ID
P => $ VECTOR
P => [ RUTINA ]
P => E
E => integer
E => string 
E => double
EXPR => expr { EXPRESION }
BODY => SET ; BODY
BODY => GETS BODY
BODY => PUTS BODY
BODY => AGR ; BODY
BODY => [ EXPR ] ; BODY
BODY => RUTINA ; BODY
BODY => IF BODY
BODY => SWITCH BODY
BODY => WHILE BODY
BODY => FOR BODY
BODY => continue ; BODY
BODY => break ; BODY
BODY => RETURN ; BODY
BODY => epsilon
RETURN => return R
R => AGR
R => VECTOR
R => $ ID 
R => RUTINA 
R => epsilon
IF => if { EXPRESION } then { BODY } ELSE
ELSE => elseif { EXPRESION } then { BODY } ELSE
ELSE => else { BODY }
ELSE => epsilon
SET_A => SET_FOR
SET_A => epsilon 
SET_FOR => set ID VAL_SET_FOR
VAL_SET_FOR => integer 
VAL_SET_FOR => $ ID
VAL_SET_FOR => $ ARRAY
VAL_SET_FOR => EXPR
INCR => incr ID VAL_INCR
VAL_INCR => integer 
VAL_INCR => $ ID  
VAL_INCR => epsilon
INCR => epsilon  
FOR => for {  SET_A } { EXPRESION } { INCR }{ BODY }
WHILE => while { EXPRESION } { BODY }
SWITCH => switch $ ID { case integer { BODY } CASE }
CASE => case integer { BODY } CASE
CASE => default { BODY }
CASE => epsilon
PROC => proc ID { PARAM } { BODY }
PARAM => { ID } PARAM
PARAM => epsilon
RUTINA => [ ID  ARGMT ] 
ARGMT => { $ ID }   ARGMT
ARGMT => { EXPR }   ARGMT
ARGMT => { RUTINA } ARGMT
ARGMT => { [ ARRAY ] } ARGMT
ARGMT => epsilon
EXPRESION => EXPRESION OP_BINARIO EXPRESION
EXPRESION => OP_UNARIO EXPRESION 
EXPRESION => E
EXPRESION => ( EXPRESION )
OP_BINARIO => + 
OP_BINARIO => * 
OP_BINARIO => - 
OP_BINARIO => / 
OP_BINARIO => > 
OP_BINARIO => < 
OP_BINARIO => >= 
OP_BINARIO => <= 
OP_BINARIO => == 
OP_BINARIO => || 
OP_BINARIO => && 
OP_BINARIO => %  
OP_BINARIO => eq  
OP_BINARIO => ne  
OP_BINARIO => != 
OP_UNARIO => + 
OP_UNARIO => - 
OP_UNARIO => ! 